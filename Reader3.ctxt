#BlueJ class context
comment0.params=args
comment0.target=void\ main([)
comment1.params=res\ Nd\ Na\ N\ Od\ Oa\ O\ cp\ cb\ ne\ start\ end\ seq\ hout
comment1.target=int\ getHbond(int,\ [,\ [,\ [,\ [,\ [,\ [,\ [,\ [,\ [,\ int,\ int,\ [,\ PrintWriter)
comment1.text=getHbond\ntakes\ int,\ double[][],\ double[][],\ double[][],\ double[][],\ double[][],\ double[][],\ double[][],\ int,\ int\ ,char\nreturns\ int\ (dummy\ placeholder\ for\ now)\nInput\:\ (residue\ to\ test\ for\ possible\ H\ bonds\ on,\ Nitrogen\ donor\ position\ array,\ Nitrogen\ acceptor\ position\ array\nNitrogen\ backbone\ position\ array,\ Oxygen\ donor\ position\ array,\ Oxygen\ acceptor\ position\ array,\nOxygen\ backbone\ position\ array,\ the\ C'\ position\ arrau,\ the\ C\ beta\ position\ array,\nthe\ bond\ angle\ atom\ postion\ array\ (see\ comments\ below),\ start\ residue,\ end\ residue,\ sequence\ array)\n\nThis\ function\ takes\ in\ information\ regarding\ the\ positions\ of\ the\ atoms\ that\ play\ a\ role\ in\ hydrogen\ bonding,\nit\ determines\ whether\ or\ not\ there\ is\ a\ possible\ hydrogen\ bond\ by\ finding\ the\ distance\ between\ two\ atoms\ that\ncould\ participate\ in\ a\ hydrogen\ bond\ with\ eachother.\ The\ distances\ were\ taken\ from\ Whitford's\ Proteins.\ The\ distance\nof\ the\ covalent\ bond\ between\ the\ atom\ and\ its\ hydrogen\ is\ assumed\ to\ be\ 0.96\ A\ (Wikipedia).\ If\ there\ is\ a\ hydrogen\ bond\nthe\ type\ of\ H\ bond\ as\ well\ as\ the\ asociated\ atom\ and\ residues\ are\ outputed\ to\ the\ screen.\ This\ information\ is\ then\ also\noutputed\ to\ a\ file\ Reader3Hbond.dat\n\nTo\ determine\ the\ bond\ angles\ of\ the\ H\ bonds\ we\ need\ to\ have\ another\ atom\ take\ another\ atom\ into\ account\ to\ determine\nthe\ angles\ at\ which\ the\ hydrogen\ bonds\ are\ formed\ and\ throw\ out\ the\ ones\ at\ too\ sharp\ of\ an\ angle.\nTo\ do\ this\ we\ look\ at\ the\ next\ heavy\ atom\ next\ to\ the\ acceptor\ or\ donor\ and\ find\ the\ angle\ between\ the\ vector\ that\nruns\ from\ heavy\ atom\ to\ heavy\ atom\ along\ the\ covalent\ bond\ and\ the\ vector\ that\ runs\ from\ the\ heavy\ atom\ all\ the\ way\nacross\ the\ H\ bond\ to\ the\ donor\ or\ accepto\ atom.\ This\ will\ define\ the\ angle\ of\ our\ H\ bond\ and\ we\ can\ put\ restrictions\ on\ it\nIn\ Protiens\ page\ 56\ it\ is\ stated\ that\ H\ bonds\ can\ have\ up\ to\ a\ +/-\ 40\ degree\ shift\ from\ the\ horizontal.\ In\ the\ 3\ spatial\ndimensions\ that\ we\ are\ working\ in\ this\ equates\ to\ a\ cone\ of\ possible\ H\ bonding\ for\ every\ donor/acceptor.\ The\ heavy\ atoms\nthat\ we\ are\ using\ to\ compute\ the\ H\ bond\ angles\ are\:\nAmide-carbonyl\:\ C'\nAmide-hydroxyl\:\ C\ beta\nAmide-imidozole\:\ NE2\nHydroxyl-carbonyl\:\ C'\nHydroxyl-Hydroxyl\:\ no\ restriction\n\nan\ example\ of\ the\ angle\ is\ (amide-carbonyl)\:\n\n\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ /\nN\ -\ H\ --\ O\ \=\ C'\n/\ \ \ \ \ \ \ \ \ \ \ \ \ \ \\\n\nThe\ angle\ between\ the\ vector\ that\ points\ from\ C'\ to\ O\ and\ the\ vector\ that\ points\ from\ C'\ to\ N.\n\n
comment10.params=phi\ psi
comment10.target=int\ classifyPhiPsi(double,\ double)
comment10.text=classifyPhiPsi\ntakes\ double,\ double\nreturns\ int\ninput\:\ (phi\ angle,\ psi\ angle)\n\nThis\ function\ takes\ in\ the\ phi\ and\ psi\ angle\ for\ a\ residue\ and\ returns\nwhat\ type\ of\ secondary\ structure\ that\ the\ residue\ is\ in\n0\:\ Beta\n1\:\ Right\ handed\ alpha\n2\:\ Left\ handed\ alpha\n\nIt\ determines\ this\ by\ using\ the\ plot\ on\ page\ 49\ of\ Whitford's\ Protiens\nBeta\:\ phi\ <\ 0,\ psi\ >\ 1\ or\ psi\ <\ -2\nRH\ Alpha\:\ phi\ <\ 0,\ -2\ <\ psi\ <\ 1\nLH\ Alpha\:\ phi\ >\ 0\n\n
comment11.params=res\ CAgrid
comment11.target=boolean\ onCorner(int,\ [)
comment11.text=onCorner\ntakes\ int,\ double[][]\nreturns\ boolean\ninput\:\ (residue\ that\ you\ want\ to\ check,\ the\ C\ alpha\ position\ array)\n\nThis\ function\ checks\ to\ see\ if\ a\ residue\ is\ on\ the\ corner\ of\ the\ helix\nit\ does\ this\ by\ making\ vector\ that\ point\ from\ the\ suspect\ residue\ to\nthe\ residue\ before\ and\ after\ it.\ Then\ by\ using\ the\ dot\ product\ rule\:\nu*v\ \=\ |u||v|cos(theta)\nif\ the\ angle\ between\ them\ is\ less\ than\ 110\ deg\ or\ 1.920\ radians\ then\nit\ is\ determined\ that\ the\ residue\ is\ on\ a\ corner\ and\ the\ value\ntrue\ is\ returned.\n\n
comment12.params=r
comment12.target=double\ getVol(char)
comment12.text=getVol\ntakes\ char\nreturns\ double\ninput\:\ (The\ character\ code\ for\ the\ amino\ acid\ that\ you\ want\ the\ volume\ for)\n\nThis\ function\ will\ take\ in\ the\ letter\ code\ for\ an\ amino\ acid\ and\ return\nthe\ VDW\ volume\ of\ the\ amino\ acid\ as\ defined\ by\ Whitford\ in\ Protiens\ on\ page\ 18-22\nThis\ includes\ the\ backbone\ (GLY\ as\ a\ non-zero\ volume)\n\n
comment13.params=r
comment13.target=int\ getNum(char)
comment13.text=getNum\ntakes\:\ char\nreturns\:\ int\ninput\:\ (The\ character\ code\ for\ an\ amino\ acid)\n\nThis\ function\ simply\ orders\ the\ amino\ acids\ in\ the\ same\ way\ that\ Whitford\ does\ in\ Protiens\nand\ returns\ the\ number\ value\ of\ thier\ position\ starting\ from\ 0\nThis\ has\ no\ scientific\ use,\ it\ is\ merely\ a\ trick\ to\ make\ some\ arrays\ more\ compact\ and\ simple\n\n
comment14.params=i
comment14.target=int\ getName(int)
comment14.text=getName\ntakes\:\ int\nreturns\:\ char\ninput\:\ (The\ number\ value\ of\ an\ amino\ acid)\n\nThis\ function\ basically\ undoes\ getNum\ for\ when\ the\ data\ needs\ to\ be\ read\nlogically\ from\ the\ array.\ It\ does\ nothing\ without\ first\ using\ getNum.\n\n
comment15.params=r
comment15.target=double\ getHydro(char)
comment15.text=getHydro\ntakes\:\ char\nreturns\:\ double\ninput\:\ (the\ char\ value\ for\ an\ amino\ acid)\n\nThis\ function\ returns\ the\ hydrophobisity\ of\ an\ amino\ acid\nfor\ a\ hydrophobe\ this\ value\ is\ 1\nfor\ anything\ else\ the\ current\ value\ is\ -1\nThis\ can\ be\ changed\ on\ a\ grouping\ basis\ (4\ groups\ are\ already\ defined\:\nhydrophobes,\ hydrophiles,\ acids,\ and\ bases)\nThis\ has\ the\ effect\ of\ giveing\ larger\ positive\ numbers\ to\ hydrophobic\ things\nand\ larger\ (in\ magnitude)\ positive\ numbers\ to\ hydrophilic\ things\n\n
comment16.params=r
comment16.target=int\ getHydroType(char)
comment16.text=getHydroType\ntakes\ char\nreturns\ int\ninput\:\ (character\ code\ for\ an\ amino\ acid)\n\nThis\ function\ returns\ what\ hydrophobic\ group\ an\ amino\ acid\ belongs\ to\n0.\ Hydrophobes\n1.\ Hydrophiles\n2.\ bases\n3.\ acids\nThis\ can\ be\ easily\ expanded\ or\ contracted\ to\ make\ more\ gorups\ or\ change\ groups\n\n
comment17.params=res
comment17.target=char\ seqres(String)
comment17.text=seqres\ntakes\ String\nreturns\ char\ninput\:\ (The\ three\ letter\ code\ for\ any\ amino\ acid)\n\nThis\ function\ basically\ turns\ the\ three\ letter\ code\ for\ any\ amino\ acid\ into\nits\ one\ letter\ code\ and\ returns\ it.\n\n
comment18.params=x\ y\ rotx\ roty\ protx\ proty
comment18.target=int\ getSector(double,\ double,\ double,\ double,\ double,\ double)
comment18.text=getSector\ntakes\ double,\ double,\ double,\ double,\ double,\ double\nreturns\ int\ninput\:\ (x\ coord\ of\ test\ point,\ y\ coord\ of\ test\ point,\nx\ coord\ of\ rotation\ vector,\ y\ coord\ of\ rotation\ vector\nx\ coord\ of\ vector\ orthogonal\ to\ rotaion\ vector,\ y\ coord\ of\ vector\ orthogonal\ to\ rotation\ vector)\n\nThis\ function\ returns\ what\ sector\ a\ test\ point\ is\ in,\ in\ relation\ to\ the\ rotation\ vector\nthe\ sectors\ are\ defined\ as\ follows\:\n\n\\\ \ II\ |\ II\ \ /\ <-\ Vector\ orthogonal\ to\ rotation\ vector\n\\\ \ \ \ |\ \ \ \ /\n\\\ \ \ |\ \ \ /\nI\ \ \\\ \ |\ \ /\ \ III\n\\\ |\ /\n_____\\|/_____\n/|\\\nI\ \ \ /\ |\ \\\ \ \ III\n/\ \ |\ \ \\\n/\ \ \ |\ \ \ \\\n/\ IV\ |\ IV\ \\\ <-\ Rotation\ vector\n\n
comment19.params=rotX\ rotY\ rotZ\ ins
comment19.target=void\ transPDB(boolean,\ boolean,\ boolean,\ String)
comment19.text=transPDB\ntakes\ boolean,\ boolean,\ boolean,\ String\nreturns\ void\ (outputs\ to\ a\ file)\ninput\:\ (reflection\ about\ x\ axis?,\ y\ axis?,\ z\ axis?,\ input\ file)\nthe\ input\ is\ defined\ on/around\ line\ 625\n\nThis\ function\ will\ reflect\ the\ *.pdb\ file\ about\ the\ x,\ y,\ and/or\ z\ axis\ and\ export\ the\ new\ncoordinate\ file\ to\ trans.pdb\n\nThis\ can\ be\ used\ to\ artificially\ force\ a\ protien\ to\ assume\ a\ right\ handed\ helix\ instead\ of\na\ left\ handed\ helix,\ or\ in\ combination\ with\ the\ ramRot\ function\ can\ generate\ almost\ entirely\nnew\ protien\ configurations\ from\ an\ already\ stable\ *.pdb\ file\n\n
comment2.params=a\ b\ c\ angle
comment2.target=boolean\ angleWithin([,\ [,\ [,\ double)
comment2.text=angleWithin\ntakes\:\ double[],\ double[],\ double[],\ double\nreturns\ boolean\ninput\:\ (donor\ position,\ heavy\ atom\ angle\ refrence\ position,\ acceptor\ position,\ angle\ it\ must\ be\ less\ than\ (radians)\n\nThis\ function\ returns\ true\ if\ the\ vector\ from\ b\ to\ a\ makes\ an\ angle\ less\ than\ a\ specified\ angle\nwith\ the\ vector\ that\ points\ from\ b\ to\ c,\ and\ false\ otherwise\n\n
comment3.params=CAgrid\ START\ END
comment3.target=double\ findVolApp([,\ int,\ int)
comment3.text=findVolApp\ntakes\:\ double[][],\ int,\ int\nreturns\ double\ninput\:\ (C\ alpha\ position\ array,\ starting\ residue,\ ending\ residue)\n\nThis\ will\ find\ an\ approximation\ to\ the\ volume\ by\ assuming\ that\ the\ helix\ is\ a\ triangular\ cylinder\nit\ finds\ the\ value\ of\ the\ longest\ side\ of\ the\ (effectivly)\ equiladiral\ triangle\nand\ then\ compute\ the\ volume\ by\ using\ (3)^(1/2)/4*L^2*H\nwhere\ L\ is\ the\ length\ of\ a\ side\ of\ the\ equiladiral\ triangle\ and\nwhere\ H\ is\ the\ hieght\ of\ the\ structure\n\n
comment4.params=res\ CAgrid\ Ngrid\ CPgrid\ len
comment4.target=double\ getPhi(int,\ [,\ [,\ [,\ int)
comment4.text=getPhi\ntakes\:\ int,\ double[][],\ double[][],\ double[][],\ int\nreturns\ double\ninput\:\ (residue\ that\ you\ want\ the\ phi\ angle\ for,\ C\ alpha\ position\ array,\ N\ position\ array,\ C'\ position\ array,\ length\ of\ the\ 1D\ string\ of\ residues\ that\ make\ up\ the\ helix\ (END-START)\n\nThis\ finds\ the\ phi\ angle\ defined\ by\ the\ angle\ between\ the\ two\ planes\ that\ are\ defined\ as\nplane\ 1\:\ the\ plane\ in\ 3-space\ consisting\ of\ the\ positions\ of\ the\ N,\ C'\ (from\ the\ previous\ residue)\ and\ CA\ atoms\nplane\ 2\:\ the\ plane\ in\ 3-space\ consisting\ of\ the\ positions\ of\ the\ C\ alpha,\ N\ and\ C'\ atoms\n\nfor\ more\ information\ look\ up\ information\ regarding\ a\ Ramachandran\ Plot\ (page\ 48\ of\ Protiens)\n\n
comment5.params=res\ CAgrid\ Ngrid\ CPgrid\ len
comment5.target=double\ getPsi(int,\ [,\ [,\ [,\ int)
comment5.text=getPsi\ntakes\:\ int,\ double[][],\ double[][],\ double[][],\ int\nreturns\ double\ninput\:\ (residue\ that\ you\ want\ the\ psi\ angle\ for,\ C\ alpha\ position\ array,\ N\ position\ array,\ C'\ position\ array,\ length\ of\ the\ 1D\ string\ of\ residues\ that\ make\ up\ the\ helix\ (END-START)\n\nThis\ finds\ the\ psi\ angle\ defined\ by\ the\ angle\ between\ the\ two\ planes\ that\ are\ defined\ as\nplane\ 1\:\ the\ plane\ in\ 3-space\ consisting\ of\ the\ positions\ of\ the\ N\ (from\ the\ following\ residue),\ C'\ and\ CA\ atoms\nplane\ 2\:\ the\ plane\ in\ 3-space\ consisting\ of\ the\ positions\ of\ the\ C\ alpha,\ N\ and\ C'\ atoms\n\nfor\ more\ information\ look\ up\ information\ regarding\ a\ Ramachandran\ Plot\ (Page\ 48\ of\ Protiens)\n\n
comment6.params=CAgrid\ len\ strict\ isLH
comment6.target=double\ findVolume([,\ int,\ boolean,\ boolean)
comment6.text=findVolume\ntakes\:\ double[][],\ int,\ boolean,\ boolean\nreturns\ double\ninput\ (C\ alpha\ position\ array,\ length\ of\ 1D\ helix\ (END-START),\ strictness\ of\ the\ in/out\ test\:\ true\ includes\ planar\ caps\ to\ the\ helix,\ is\ the\ helix\ left\ handed?)\n\nThis\ function\ computes\ the\ volume\ of\ the\ helix\ using\ Monte\ Carlo\ integration\nIt\ finds\ the\ range\ of\ space\ the\ the\ helix\ is\ in\ and\ generates\ a\ ranfom\ test\ point\nit\ then\ finds\ the\ closest\ C\ alpha\ to\ that\ test\ point\ and\ tests\ whether\ or\ not\ it\ is\ inside\ the\ helix\nby\ pretending\ that\ the\ point\ is\ that\ C\ alphas\ corresponding\ C\ beta\ point\nIf\ it\ is\ inside\ the\ helix\ then\ it\ is\ added\ to\ the\ count\n\nat\ the\ end\ we\ use\ the\ monte\ carlo\ integration\ formula\ that\ V\ \=\ (in/total)*(space\ of\ possible\ values)\n\n
comment7.params=res\ min\ minsearch\ minstart\ searchDomP\ CAgrid
comment7.target=int\ getNplus(int,\ int,\ int,\ int,\ int,\ [)
comment7.text=getNplus\ntakes\:\ int,\ int,\ int,\ int,\ int,\ double[][]\ \ //\ That\ is\ 5\ ints\nreturns\ int\ninput\:\ (residue\ that\ you\ want\ Nplus\ for,\ minimum\ distance\ away\ it\ will\ evaluate\ against\ (3),\ dummy\ variable\ (0),\ where\ it\ starts\ when\ looking\ for\ the\ residue\ (9),\ how\ deep\ into\ the\ 1D\ chain\ it\ will\ search\ (must\ be\ less\ than\ the\ number\ of\ residues\ left),\ C\ alpha\ postion\ array)\n\nThis\ function\ searches\ for\ and\ returns\ the\ number\ of\ residues\ in\ between\ it\ and\ the\ residue\ directly\ above\ it\ in\ the\ helix\nIt\ starts\ by\ looking\ at\ some\ residue\ a\ minumum\ distance\ away\ and\ compares\ it\ to\ the\ distance\ between\ it\ and\ another\ residue\ which\ is\ relivly\ close\nif\ it\ is\ closer\ than\ the\ criteria\ then\ it\ becomes\ the\ new\ closeset\ and\ it\ tries\ to\ find\ a\ residue\ which\ is\ closer\ yet\nif\ there\ is\ no\ residue\ above\ it\ (if\ its\ at\ the\ top\ of\ the\ helix)\ then\ it\ returns\ a\ value\ of\ zero\n\n
comment8.params=res\ min\ minsearch\ minstart\ searchDomM\ CAgrid
comment8.target=int\ getNminus(int,\ int,\ int,\ int,\ int,\ [)
comment8.text=getNminus\ntakes\ int,\ int,\ int,\ int,\ int,\ double[][]\nreturns\ int\ninput\:\ (residue\ that\ you\ want\ Nplus\ for,\ minimum\ distance\ away\ it\ will\ evaluate\ against\ (3),\ dummy\ variable\ (0),\ where\ it\ starts\ when\ looking\ for\ the\ residue\ (9),\ how\ deep\ into\ the\ 1D\ chain\ it\ will\ search\ (must\ be\ less\ than\ the\ number\ of\ residues\ left),\ C\ alpha\ postion\ array)\n\nThis\ works\ in\ exactly\ the\ same\ way\ as\ getNplus\ only\ in\ the\ opposite\ direction\n\n
comment9.params=res\ x\ y\ z\ CAgrid\ len\ strict\ isLH
comment9.target=boolean\ CBisInside(int,\ double,\ double,\ double,\ [,\ int,\ boolean,\ boolean)
comment9.text=CBisInside\ntakes\ int,\ double,\ double,\ double,\ double[][],\ int,\ boolean,\ boolean\nreturns\ boolean\ninput\ (the\ residue\ that\ we\ are\ comparing\ the\ test\ point\ to\ (usually\ the\ closest\ c\ alpha),\nthe\ x\ coord\ of\ the\ test\ point,\ the\ y\ coord\ of\ the\ test\ point,\ the\ z\ coord\ of\ the\ test\ point,\nthe\ position\ array\ of\ the\ C\ alpha\ atoms,\ the\ 1D\ length\ of\ helix\ (END-START),\nthe\ strictness\ of\ the\ algorithm\:\ true\ will\ include\ planar\ caps\ to\ the\ helix,\nwhether\ or\ not\ the\ helix\ is\ left\ handed\ (true)\ or\ right\ handed\ (false))\n\nThis\ function\ will\ test\ whether\ a\ single\ point\ in\ 3-space\ lies\ inside\ the\ helix\nto\ do\ this\ 5\ refrence\ points\ are\ found,\ the\ closest\ C\ alpha,\ the\ C\ alphas\ on\ either\ side\ of\ that,\nand\ the\ C\ alpha\ right\ above\ and\ right\ below\ that\ closest\ C\ alpha\nvectors\ are\ then\ made\ to\ point\ from\ that\ closest\ C\ alpha\ towards\ the\ other\ 4\ points\nthese\ vectors\ make\ up\ 4\ planes\ that\ are\ an\ approximation\ to\ the\ side\ of\ the\ helix\nthe\ cross\ product\ of\ these\ vectors\ (if\ taken\ in\ the\ right\ order)\ will\ produce\ a\nvector\ that\ will\ always\ point\ inwards\ (due\ to\ the\ consistant\ left\ handed\ nature\ of\ the\ helix)\nwe\ then\ calculate\ the\ dot\ product\ of\ the\ vector\ that\ points\ from\ the\ closest\ C\ alpha\ to\ the\ C\ beta\n(or\ any\ point\ that\ we\ wish\ to\ test)\ and\ the\ cross\ product\ vector\ from\ one\ of\ the\ planes\nif\ this\ dot\ product\ is\ positive\ then\ the\ vector\ points\ in\ and\ the\ point\ (or\ C\ beta\ and\ therefore\nthe\ side\ chain)\ is\ inside\ the\ helix.\ We\ then\ repeat\ this\ step\ for\ the\ other\ (up\ to\ 3)\ sides.\nThe\ vector\ must\ pass\ a\ majority\ (>50%)\ of\ these\ tests\ for\ it\ to\ be\ considered\ "in."\nThere\ are\ some\ circumstances\ where\ there\ is\ no\ upper\ C\ alpha\ or\ no\ C\ alpha\ to\ the\ right\ etc.\nfor\ these\ situations\ only\ the\ possible\ tests\ are\ done.\n\nIf\ strict\ \=\=\ true\ then\ the\ function\ takes\ another\ step\ and\ puts\ another\ restriction\ on\ the\ test\nplanar\ caps\ are\ formed\ at\ the\ top\ and\ bottom\ of\ the\ helix\ in\ order\ to\ determine\ whether\ or\ not\nthe\ point\ is\ oriented\ inwards\ but\ is\ too\ far\ "above"\ the\ helix\ to\ be\ counted\ "in."\nThe\ caps\ are\ constructed\ by\ finding\ points\ on\ the\ top\ and\ bottom\ rungs\ of\ the\ helix\ that\ are\ in\nthe\ corners.\ A\ equation\ of\ a\ plane\ is\ then\ found\ using\ these\ points.\ We\ then\ test\ a\ point\ that\ is\nknown\ to\ be\ on\ the\ correct\ (in)\ side\ of\ the\ plane\ and\ make\ sure\ that\ all\ subsequent\ points\ follow\nthe\ same\ inequality.\ If\ either\ of\ these\ tests\ fail\ then\ the\ particle\ imeadiatly\ fails.\ This\ strict\nparameter\ does\ not\ need\ to\ be\ invoked\ when\ simply\ checking\ whether\ a\ C\ beta\ is\ inside\ or\ not,\ becuase\none\ can\ be\ reasonably\ certain\ that\ orientation\ will\ dictate\ whether\ the\ side\ chain\ is\ in\ or\ not.\nWhen\ performing\ the\ Monte\ Carlo\ integration\ on\ the\ other\ hand,\ points\ are\ not\ restricted\ to\ the\ same\ngeometry\ as\ teh\ side\ chains\ and\ without\ the\ strictness\ points\ above\ and\ below\ the\ helix\ (enough\ so\nto\ be\ deemed\ out\ logically)\ will\ still\ be\ counted\ "in"\ based\ on\ orientation\ alone\ if\ the\ planar\ caps\nare\ not\ inforced.\n\nIf\ the\ helix\ is\ left\ handed\ then\ it\ will\ orient\ the\ cross\ products\ so\ that\ they\ point\ in\ and\ check\ the\ntest\ vector\ against\ them\ in\ a\ positive\ way\ (see\ if\ they\ DO\ point\ along\ the\ same\ line).\ If\ the\ helix\ is\nright\ handed\ then\ it\ will\ orient\ the\ cross\ products\ so\ that\ the\ test\ vector\ wants\ to\ point\ in\ the\ opposite\ndirection\ to\ be\ counted\ in.\ Left\ handed\ \=\ true,\ Right\ handed\ \=\ false.\n\n
numComments=20
